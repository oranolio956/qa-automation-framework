#!/usr/bin/env python3
"""
Security Test Suite - Tests for policy injection, bypass attempts, and security vulnerabilities
"""

import requests
import json
import time
import jwt
import os
import base64
from datetime import datetime, timedelta

# Configuration
BACKEND_URL = "http://localhost:8000"
OPA_URL = "http://localhost:8181"

# Get JWT secret from environment 
try:
    from utils.vault_client import get_secret
    JWT_SECRET = get_secret('JWT_SECRET')
    if not JWT_SECRET:
        raise ValueError("JWT_SECRET not found")
except Exception:
    JWT_SECRET = os.environ.get('JWT_SECRET')
    if not JWT_SECRET:
        raise ValueError("JWT_SECRET must be set for security testing")

def generate_malicious_jwt(payload_override=None):
    """Generate JWT with malicious payloads"""
    base_payload = {
        'user_id': 'attacker',
        'customer_id': 'victim_customer',
        'exp': datetime.utcnow() + timedelta(hours=1),
        'iat': datetime.utcnow()
    }
    
    if payload_override:
        base_payload.update(payload_override)
    
    return jwt.encode(base_payload, JWT_SECRET, algorithm='HS256')

def test_jwt_algorithm_confusion():
    """Test for JWT algorithm confusion attacks"""
    print("üîç Testing JWT algorithm confusion...")
    
    attacks = [
        # None algorithm attack
        {
            'name': 'None Algorithm',
            'token': jwt.encode({'user_id': 'admin', 'customer_id': 'admin'}, None, algorithm=None),
        },
        # HS256 with public key attack (if RS256 was expected)
        {
            'name': 'Algorithm Confusion HS256',
            'token': jwt.encode({'user_id': 'admin', 'customer_id': 'admin'}, 'public_key', algorithm='HS256'),
        }
    ]
    
    results = []
    for attack in attacks:
        try:
            headers = {'Authorization': f'Bearer {attack["token"]}'}
            response = requests.get(f"{BACKEND_URL}/orders", headers=headers, timeout=5)
            
            if response.status_code == 200:
                print(f"‚ùå VULNERABILITY: {attack['name']} attack succeeded!")
                results.append(False)
            else:
                print(f"‚úÖ {attack['name']} attack blocked: {response.status_code}")
                results.append(True)
                
        except Exception as e:
            print(f"‚úÖ {attack['name']} attack failed with exception: {e}")
            results.append(True)
    
    return all(results)

def test_privilege_escalation():
    """Test for privilege escalation attempts"""
    print("üîç Testing privilege escalation...")
    
    escalation_payloads = [
        {'user_id': 'admin', 'customer_id': 'normal_user'},  # Admin role with normal customer
        {'user_id': 'normal_user', 'customer_id': 'admin'},  # Normal user accessing admin data
        {'user_id': 'support', 'customer_id': 'any_customer', 'role': 'admin'},  # Role injection
        {'user_id': '../../../admin', 'customer_id': 'test'},  # Path traversal in user_id
        {'user_id': 'user\\'; DROP TABLE users; --', 'customer_id': 'test'},  # SQL injection attempt
    ]
    
    results = []
    for payload in escalation_payloads:
        try:
            token = generate_malicious_jwt(payload)
            headers = {'Authorization': f'Bearer {token}'}
            response = requests.get(f"{BACKEND_URL}/orders", headers=headers, timeout=5)
            
            if response.status_code == 200:
                print(f"‚ùå VULNERABILITY: Privilege escalation with payload {payload}")
                results.append(False)
            else:
                print(f"‚úÖ Privilege escalation blocked: {response.status_code}")
                results.append(True)
                
        except Exception as e:
            print(f"‚úÖ Privilege escalation failed: {e}")
            results.append(True)
    
    return all(results)

def test_opa_policy_injection():
    """Test for OPA policy injection attacks"""
    print("üîç Testing OPA policy injection...")
    
    injection_attempts = [
        # Direct OPA policy manipulation
        {
            'name': 'Direct Policy Query',
            'url': f"{OPA_URL}/v1/data",
            'payload': {"input": {"malicious": "true"}},
        },
        # Policy data extraction
        {
            'name': 'Policy Data Extraction',
            'url': f"{OPA_URL}/v1/policies",
            'payload': {},
        },
        # Config manipulation
        {
            'name': 'Config Access',
            'url': f"{OPA_URL}/v1/config",
            'payload': {},
        }
    ]
    
    results = []
    for attempt in injection_attempts:
        try:
            response = requests.post(attempt['url'], json=attempt['payload'], timeout=5)
            
            if response.status_code == 200 and 'result' in response.text:
                print(f"‚ùå VULNERABILITY: {attempt['name']} succeeded")
                results.append(False)
            else:
                print(f"‚úÖ {attempt['name']} blocked: {response.status_code}")
                results.append(True)
                
        except Exception as e:
            print(f"‚úÖ {attempt['name']} failed: {e}")
            results.append(True)
    
    return all(results)

def test_path_traversal_attacks():
    """Test for path traversal in API endpoints"""
    print("üîç Testing path traversal attacks...")
    
    traversal_paths = [
        "/orders/../../../etc/passwd",
        "/orders/%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",  # URL encoded
        "/orders/..\\..\\..\\windows\\system32\\config\\sam",  # Windows paths
        "/orders/../admin/secrets",
        "/orders/./../../internal/config",
    ]
    
    token = generate_malicious_jwt({'user_id': 'attacker', 'customer_id': 'test'})
    headers = {'Authorization': f'Bearer {token}'}
    
    results = []
    for path in traversal_paths:
        try:
            response = requests.get(f"{BACKEND_URL}{path}", headers=headers, timeout=5)
            
            if response.status_code == 200:
                print(f"‚ùå VULNERABILITY: Path traversal succeeded for {path}")
                results.append(False)
            else:
                print(f"‚úÖ Path traversal blocked for {path}: {response.status_code}")
                results.append(True)
                
        except Exception as e:
            print(f"‚úÖ Path traversal failed for {path}: {e}")
            results.append(True)
    
    return all(results)

def test_injection_attacks():
    """Test for various injection attacks"""
    print("üîç Testing injection attacks...")
    
    injection_payloads = [
        # Header injection
        {
            'headers': {
                'Authorization': f'Bearer {generate_malicious_jwt()}',
                'X-Injected-Header': 'malicious\r\nSet-Cookie: admin=true',
                'User-Agent': '<script>alert("xss")</script>'
            }
        },
        # JSON injection in request body
        {
            'headers': {'Authorization': f'Bearer {generate_malicious_jwt()}'},
            'json': {
                'job_type': 'touch_test"; DROP TABLE orders; --',
                'quantity': '1 OR 1=1',
                'parameters': {'__proto__': {'admin': True}}  # Prototype pollution
            }
        }
    ]
    
    results = []
    for payload in injection_payloads:
        try:
            response = requests.post(
                f"{BACKEND_URL}/orders",
                headers=payload.get('headers', {}),
                json=payload.get('json'),
                timeout=5
            )
            
            # Any successful response to malicious payload is a concern
            if response.status_code in [200, 201]:
                print(f"‚ùå POTENTIAL VULNERABILITY: Injection payload accepted")
                results.append(False)
            else:
                print(f"‚úÖ Injection payload rejected: {response.status_code}")
                results.append(True)
                
        except Exception as e:
            print(f"‚úÖ Injection payload failed: {e}")
            results.append(True)
    
    return all(results)

def test_opa_circuit_breaker_bypass():
    """Test attempts to bypass OPA circuit breaker"""
    print("üîç Testing OPA circuit breaker bypass...")
    
    # Generate rapid requests to trigger circuit breaker
    token = generate_malicious_jwt()
    headers = {'Authorization': f'Bearer {token}'}
    
    # First, try to overwhelm OPA
    print("Attempting to trigger circuit breaker...")
    for i in range(10):
        try:
            # Make requests that should fail OPA policy checks
            requests.get(f"{BACKEND_URL}/orders", headers=headers, timeout=0.1)
        except:
            pass  # Ignore timeouts/errors
    
    # Now test if circuit breaker can be bypassed
    try:
        response = requests.get(f"{BACKEND_URL}/orders", headers=headers, timeout=5)
        
        if response.status_code == 200:
            print("‚ùå POTENTIAL ISSUE: Request succeeded despite circuit breaker")
            return False
        else:
            print(f"‚úÖ Circuit breaker working: {response.status_code}")
            return True
            
    except Exception as e:
        print(f"‚úÖ Circuit breaker blocked request: {e}")
        return True

def test_audit_log_tampering():
    """Test for audit log tampering attempts"""
    print("üîç Testing audit log tampering...")
    
    tampering_attempts = [
        # Try to access audit logs
        {'path': '/logs/audit', 'method': 'GET'},
        {'path': '/internal/audit', 'method': 'GET'},
        {'path': '/metrics', 'method': 'DELETE'},  # Try to delete metrics
        # Try to inject false audit events
        {'path': '/webhook', 'method': 'POST', 'json': {'fake': 'audit_event'}},
    ]
    
    results = []
    for attempt in tampering_attempts:
        try:
            token = generate_malicious_jwt()
            headers = {'Authorization': f'Bearer {token}'}
            
            response = requests.request(
                attempt['method'],
                f"{BACKEND_URL}{attempt['path']}",
                headers=headers,
                json=attempt.get('json'),
                timeout=5
            )
            
            if response.status_code == 200:
                print(f"‚ùå POTENTIAL VULNERABILITY: Audit tampering via {attempt}")
                results.append(False)
            else:
                print(f"‚úÖ Audit tampering blocked: {response.status_code}")
                results.append(True)
                
        except Exception as e:
            print(f"‚úÖ Audit tampering failed: {e}")
            results.append(True)
    
    return all(results)

def run_security_exploit_tests():
    """Run comprehensive security exploit tests"""
    print("üö® Starting Security Exploit Tests")
    print("=" * 60)
    print("‚ö†Ô∏è  WARNING: This test suite contains actual attack patterns")
    print("   Only run against your own systems in a test environment")
    print("=" * 60)
    
    tests = [
        ("JWT Algorithm Confusion", test_jwt_algorithm_confusion),
        ("Privilege Escalation", test_privilege_escalation),
        ("OPA Policy Injection", test_opa_policy_injection),
        ("Path Traversal", test_path_traversal_attacks),
        ("Injection Attacks", test_injection_attacks),
        ("Circuit Breaker Bypass", test_opa_circuit_breaker_bypass),
        ("Audit Log Tampering", test_audit_log_tampering),
    ]
    
    results = []
    
    for test_name, test_func in tests:
        print(f"\nüéØ Running: {test_name}")
        try:
            result = test_func()
            results.append((test_name, result))
            print(f"Result: {'‚úÖ SECURE' if result else '‚ùå VULNERABLE'}")
        except Exception as e:
            print(f"‚ùå Test failed with exception: {e}")
            results.append((test_name, False))
        
        time.sleep(1)  # Brief pause between tests
    
    print("\n" + "=" * 60)
    print("üîí Security Test Results Summary")
    print("=" * 60)
    
    secure_count = 0
    total = len(results)
    
    for test_name, result in results:
        status = "‚úÖ SECURE" if result else "‚ùå VULNERABLE"
        print(f"{test_name}: {status}")
        if result:
            secure_count += 1
    
    print(f"\nüéØ Security Score: {secure_count}/{total} tests passed")
    
    if secure_count == total:
        print("üõ°Ô∏è  Excellent! All security tests passed.")
    elif secure_count >= total * 0.8:
        print("‚ö†Ô∏è  Good security posture, but some vulnerabilities found.")
    else:
        print("üö® CRITICAL: Multiple security vulnerabilities detected!")
        print("   Review and fix vulnerabilities before production deployment.")
    
    return secure_count / total

if __name__ == "__main__":
    security_score = run_security_exploit_tests()
    exit(0 if security_score == 1.0 else 1)