#!/usr/bin/env python3
"""
Android Automation Orchestrator
Coordinates emulators, UIAutomator2, touch patterns, and anti-detection for complete automation
"""

import os
import sys
import time
import logging
import asyncio
import random
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
from concurrent.futures import ThreadPoolExecutor
import threading

# Add project paths
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

# Import Android automation components
try:
    from .emulator_manager import EmulatorManager, EmulatorConfig, EmulatorInstance
    from .ui_automator_manager import UIAutomatorManager, DeviceConnectionInfo
    from .touch_pattern_generator import HumanTouchGenerator, TouchType, TouchPattern
except ImportError:
    try:
        from emulator_manager import EmulatorManager, EmulatorConfig, EmulatorInstance
        from ui_automator_manager import UIAutomatorManager, DeviceConnectionInfo  
        from touch_pattern_generator import HumanTouchGenerator, TouchType, TouchPattern
    except ImportError as e:
        logging.error(f"Failed to import Android automation components: {e}")
        sys.exit(1)

# Import anti-detection system
try:
    from core.anti_detection import get_anti_detection_system, BehaviorPattern
except ImportError:
    try:
        from automation.core.anti_detection import get_anti_detection_system, BehaviorPattern
    except ImportError:
        get_anti_detection_system = None
        BehaviorPattern = None

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class AutomationSession:
    """Complete automation session information"""
    session_id: str
    device_id: str
    emulator_instance: Optional[EmulatorInstance] = None
    u2_device: Any = None
    touch_generator: Optional[HumanTouchGenerator] = None
    behavior_pattern: Optional[Any] = None
    start_time: float = 0.0
    app_package: Optional[str] = None
    session_state: Dict = None

class AndroidAutomationOrchestrator:
    """Orchestrates complete Android automation with anti-detection"""
    
    def __init__(self, max_concurrent_sessions: int = 3):
        self.max_concurrent_sessions = max_concurrent_sessions
        self.active_sessions: Dict[str, AutomationSession] = {}
        
        # Initialize managers
        self.emulator_manager = EmulatorManager(max_concurrent=max_concurrent_sessions)
        self.ui_manager = UIAutomatorManager(max_concurrent_devices=max_concurrent_sessions)
        
        # Anti-detection system
        self.anti_detection = get_anti_detection_system() if get_anti_detection_system else None
        
        # Session executor
        self.executor = ThreadPoolExecutor(max_workers=max_concurrent_sessions)
        
        # Health monitoring
        self._start_session_monitor()
        
    def _start_session_monitor(self):
        """Start background session monitoring"""
        def monitor():
            while True:
                try:
                    self._monitor_sessions()
                    time.sleep(30)  # Check every 30 seconds
                except Exception as e:
                    logger.error(f"Session monitor error: {e}")
                    time.sleep(5)
        
        monitor_thread = threading.Thread(target=monitor, daemon=True)
        monitor_thread.start()
        logger.info("Session monitor started")
    
    def _monitor_sessions(self):
        """Monitor active automation sessions"""
        sessions_to_remove = []
        
        for session_id, session in self.active_sessions.items():
            try:\n                # Check if emulator is still running\n                if session.emulator_instance:\n                    if session.emulator_instance.process.poll() is not None:\n                        logger.warning(f\"Emulator died for session {session_id}\")\n                        sessions_to_remove.append(session_id)\n                        continue\n                \n                # Check UIAutomator2 connection\n                if session.u2_device:\n                    try:\n                        info = session.u2_device.info\n                        if not info:\n                            raise Exception(\"Device not responding\")\n                    except:\n                        logger.warning(f\"UIAutomator2 connection lost for session {session_id}\")\n                        # Try to reconnect\n                        self._reconnect_session(session)\n                \n                # Update session activity time\n                session.session_state = session.session_state or {}\n                session.session_state['last_health_check'] = time.time()\n                \n            except Exception as e:\n                logger.error(f\"Session monitoring error for {session_id}: {e}\")\n                sessions_to_remove.append(session_id)\n        \n        # Remove failed sessions\n        for session_id in sessions_to_remove:\n            try:\n                self.end_automation_session(session_id)\n            except:\n                pass\n    \n    def _reconnect_session(self, session: AutomationSession):\n        \"\"\"Attempt to reconnect a session\"\"\"\n        try:\n            if session.device_id:\n                u2_device = self.ui_manager.connect_device(session.device_id)\n                if u2_device:\n                    session.u2_device = u2_device\n                    logger.info(f\"Reconnected session {session.session_id}\")\n        except Exception as e:\n            logger.error(f\"Session reconnection failed: {e}\")\n    \n    def create_emulator_session(self, config_name: str = 'pixel_6_api_30',\n                              headless: bool = True) -> Optional[str]:\n        \"\"\"Create new emulator-based automation session\"\"\"\n        try:\n            if len(self.active_sessions) >= self.max_concurrent_sessions:\n                logger.error(\"Maximum concurrent sessions reached\")\n                return None\n            \n            # Generate session ID\n            session_id = f\"emulator_{int(time.time())}_{random.randint(1000, 9999)}\"\n            \n            logger.info(f\"Creating emulator session: {session_id}\")\n            \n            # Find emulator config\n            config = None\n            for emu_config in self.emulator_manager.device_configs:\n                if emu_config.name == config_name:\n                    config = emu_config\n                    break\n            \n            if not config:\n                logger.error(f\"Emulator config not found: {config_name}\")\n                return None\n            \n            # Create AVD\n            avd_name = f\"{config_name}_{session_id}\"\n            self.emulator_manager.create_avd(config, avd_name)\n            \n            # Start emulator\n            instance = self.emulator_manager.start_emulator(avd_name, config, headless)\n            if not instance or not instance.is_ready:\n                logger.error(f\"Failed to start emulator for session {session_id}\")\n                return None\n            \n            # Connect UIAutomator2\n            u2_device = self.ui_manager.connect_device(instance.device_id, 'emulator')\n            if not u2_device:\n                logger.error(f\"Failed to connect UIAutomator2 for session {session_id}\")\n                self.emulator_manager.stop_emulator(avd_name)\n                return None\n            \n            # Get device info for touch generator\n            device_info = self.ui_manager.get_device_info(instance.device_id)\n            screen_width = device_info.get('displayWidth', 1080) if device_info else 1080\n            screen_height = device_info.get('displayHeight', 1920) if device_info else 1920\n            \n            # Create touch generator\n            touch_generator = HumanTouchGenerator(screen_width, screen_height)\n            touch_generator.set_human_profile(random.choice(['confident', 'careful', 'young']))\n            \n            # Initialize anti-detection behavior\n            behavior_pattern = None\n            if self.anti_detection:\n                try:\n                    behavior_pattern = BehaviorPattern(aggressiveness=random.uniform(0.2, 0.5))\n                except:\n                    logger.warning(\"Failed to initialize behavior pattern\")\n            \n            # Create session\n            session = AutomationSession(\n                session_id=session_id,\n                device_id=instance.device_id,\n                emulator_instance=instance,\n                u2_device=u2_device,\n                touch_generator=touch_generator,\n                behavior_pattern=behavior_pattern,\n                start_time=time.time(),\n                session_state={\n                    'avd_name': avd_name,\n                    'screen_size': (screen_width, screen_height),\n                    'created': time.time()\n                }\n            )\n            \n            self.active_sessions[session_id] = session\n            \n            logger.info(f\"Emulator session created successfully: {session_id}\")\n            logger.info(f\"Device: {instance.device_id}, Screen: {screen_width}x{screen_height}\")\n            \n            return session_id\n            \n        except Exception as e:\n            logger.error(f\"Failed to create emulator session: {e}\")\n            return None\n    \n    def connect_physical_device(self, device_id: str = None) -> Optional[str]:\n        \"\"\"Connect to physical Android device\"\"\"\n        try:\n            if len(self.active_sessions) >= self.max_concurrent_sessions:\n                logger.error(\"Maximum concurrent sessions reached\")\n                return None\n            \n            # Discover devices if no specific device provided\n            if not device_id:\n                devices = self.ui_manager.discover_devices()\n                physical_devices = [d for d in devices if not d.startswith('emulator-')]\n                \n                if not physical_devices:\n                    logger.error(\"No physical devices found\")\n                    return None\n                \n                device_id = physical_devices[0]\n                logger.info(f\"Auto-selected device: {device_id}\")\n            \n            # Generate session ID\n            session_id = f\"physical_{device_id}_{int(time.time())}\"\n            \n            logger.info(f\"Connecting to physical device: {device_id}\")\n            \n            # Connect UIAutomator2\n            u2_device = self.ui_manager.connect_device(device_id, 'usb')\n            if not u2_device:\n                logger.error(f\"Failed to connect to device {device_id}\")\n                return None\n            \n            # Get device info\n            device_info = self.ui_manager.get_device_info(device_id)\n            if not device_info:\n                logger.error(f\"Failed to get device info for {device_id}\")\n                return None\n            \n            screen_width = device_info.get('displayWidth', 1080)\n            screen_height = device_info.get('displayHeight', 1920)\n            \n            # Create touch generator\n            touch_generator = HumanTouchGenerator(screen_width, screen_height)\n            touch_generator.set_human_profile(random.choice(['confident', 'careful']))\n            \n            # Initialize anti-detection behavior\n            behavior_pattern = None\n            if self.anti_detection:\n                try:\n                    behavior_pattern = BehaviorPattern(aggressiveness=random.uniform(0.3, 0.6))\n                except:\n                    logger.warning(\"Failed to initialize behavior pattern\")\n            \n            # Create session\n            session = AutomationSession(\n                session_id=session_id,\n                device_id=device_id,\n                u2_device=u2_device,\n                touch_generator=touch_generator,\n                behavior_pattern=behavior_pattern,\n                start_time=time.time(),\n                session_state={\n                    'device_info': device_info,\n                    'screen_size': (screen_width, screen_height),\n                    'created': time.time()\n                }\n            )\n            \n            self.active_sessions[session_id] = session\n            \n            logger.info(f\"Physical device session created: {session_id}\")\n            logger.info(f\"Device: {device_info.get('productName', 'Unknown')} - Android {device_info.get('version', 'Unknown')}\")\n            \n            return session_id\n            \n        except Exception as e:\n            logger.error(f\"Failed to connect to physical device: {e}\")\n            return None\n    \n    def install_app(self, session_id: str, apk_path: str) -> bool:\n        \"\"\"Install APK in session\"\"\"\n        session = self.active_sessions.get(session_id)\n        if not session:\n            logger.error(f\"Session not found: {session_id}\")\n            return False\n        \n        try:\n            logger.info(f\"Installing APK in session {session_id}: {apk_path}\")\n            \n            # Use emulator manager for emulator installations\n            if session.emulator_instance:\n                avd_name = session.session_state.get('avd_name')\n                success = self.emulator_manager.install_apk_on_emulator(avd_name, apk_path)\n            else:\n                # Use UI manager for physical devices\n                success = self.ui_manager.install_app(session.device_id, apk_path)\n            \n            if success:\n                logger.info(f\"APK installed successfully in session {session_id}\")\n            else:\n                logger.error(f\"APK installation failed in session {session_id}\")\n            \n            return success\n            \n        except Exception as e:\n            logger.error(f\"Install app error: {e}\")\n            return False\n    \n    def launch_app(self, session_id: str, package_name: str, activity: str = None) -> bool:\n        \"\"\"Launch app in session\"\"\"\n        session = self.active_sessions.get(session_id)\n        if not session:\n            logger.error(f\"Session not found: {session_id}\")\n            return False\n        \n        try:\n            logger.info(f\"Launching app in session {session_id}: {package_name}\")\n            \n            # Use emulator manager for emulator launches\n            if session.emulator_instance:\n                avd_name = session.session_state.get('avd_name')\n                success = self.emulator_manager.launch_app_on_emulator(avd_name, package_name, activity)\n            else:\n                # Use UI manager for physical devices\n                success = self.ui_manager.launch_app(session.device_id, package_name, activity)\n            \n            if success:\n                session.app_package = package_name\n                logger.info(f\"App launched successfully in session {session_id}\")\n            else:\n                logger.error(f\"App launch failed in session {session_id}\")\n            \n            return success\n            \n        except Exception as e:\n            logger.error(f\"Launch app error: {e}\")\n            return False\n    \n    def perform_human_tap(self, session_id: str, x: float, y: float) -> bool:\n        \"\"\"Perform human-like tap with anti-detection\"\"\"\n        session = self.active_sessions.get(session_id)\n        if not session or not session.u2_device:\n            logger.error(f\"Invalid session or device: {session_id}\")\n            return False\n        \n        try:\n            # Generate human-like tap pattern\n            tap_pattern = session.touch_generator.generate_tap_pattern(x, y)\n            \n            # Apply behavioral delay if anti-detection is available\n            if session.behavior_pattern:\n                delay = session.behavior_pattern.get_swipe_timing()\n                time.sleep(delay)\n            \n            # Execute tap using the first touch point (most accurate)\n            main_point = tap_pattern.points[0]\n            \n            # Perform the tap\n            session.u2_device.click(main_point.x, main_point.y)\n            \n            # Record action for anti-detection\n            if self.anti_detection:\n                self.anti_detection.record_action(\n                    session.device_id, 'tap',\n                    {'x': main_point.x, 'y': main_point.y, 'pattern': tap_pattern.human_characteristics}\n                )\n            \n            logger.debug(f\"Human tap performed: ({main_point.x:.1f}, {main_point.y:.1f})\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Human tap error: {e}\")\n            return False\n    \n    def perform_human_swipe(self, session_id: str, start_x: float, start_y: float,\n                           end_x: float, end_y: float, duration: float = None) -> bool:\n        \"\"\"Perform human-like swipe with anti-detection\"\"\"\n        session = self.active_sessions.get(session_id)\n        if not session or not session.u2_device:\n            logger.error(f\"Invalid session or device: {session_id}\")\n            return False\n        \n        try:\n            # Generate human-like swipe pattern\n            swipe_pattern = session.touch_generator.generate_swipe_pattern(\n                start_x, start_y, end_x, end_y, duration\n            )\n            \n            # Apply behavioral delay\n            if session.behavior_pattern:\n                delay = session.behavior_pattern.get_swipe_timing()\n                time.sleep(delay)\n            \n            # Execute swipe using pattern points\n            if len(swipe_pattern.points) >= 2:\n                start_point = swipe_pattern.points[0]\n                end_point = swipe_pattern.points[-1]\n                \n                session.u2_device.swipe(\n                    start_point.x, start_point.y,\n                    end_point.x, end_point.y,\n                    duration=swipe_pattern.total_duration\n                )\n            \n            # Record action for anti-detection\n            if self.anti_detection:\n                self.anti_detection.record_action(\n                    session.device_id, 'swipe',\n                    {'pattern': swipe_pattern.human_characteristics}\n                )\n            \n            logger.debug(f\"Human swipe performed: ({start_x:.1f}, {start_y:.1f}) -> ({end_x:.1f}, {end_y:.1f})\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Human swipe error: {e}\")\n            return False\n    \n    def take_session_screenshot(self, session_id: str, save_path: str = None) -> Optional[str]:\n        \"\"\"Take screenshot in session\"\"\"\n        session = self.active_sessions.get(session_id)\n        if not session:\n            logger.error(f\"Session not found: {session_id}\")\n            return None\n        \n        try:\n            # Use emulator manager for emulators\n            if session.emulator_instance:\n                avd_name = session.session_state.get('avd_name')\n                return self.emulator_manager.take_screenshot(avd_name, save_path)\n            else:\n                # Use UI manager for physical devices\n                return self.ui_manager.take_screenshot(session.device_id, save_path)\n                \n        except Exception as e:\n            logger.error(f\"Screenshot error: {e}\")\n            return None\n    \n    def get_session_info(self, session_id: str) -> Optional[Dict]:\n        \"\"\"Get detailed session information\"\"\"\n        session = self.active_sessions.get(session_id)\n        if not session:\n            return None\n        \n        try:\n            # Get device info\n            if session.emulator_instance:\n                avd_name = session.session_state.get('avd_name')\n                device_info = self.emulator_manager.get_emulator_info(avd_name)\n            else:\n                device_info = self.ui_manager.get_device_info(session.device_id)\n            \n            # Combine session and device info\n            return {\n                'session_id': session_id,\n                'device_id': session.device_id,\n                'session_type': 'emulator' if session.emulator_instance else 'physical',\n                'start_time': session.start_time,\n                'running_time': time.time() - session.start_time,\n                'app_package': session.app_package,\n                'touch_profile': session.touch_generator.current_profile if session.touch_generator else None,\n                'device_info': device_info,\n                'session_state': session.session_state\n            }\n            \n        except Exception as e:\n            logger.error(f\"Get session info error: {e}\")\n            return None\n    \n    def end_automation_session(self, session_id: str):\n        \"\"\"End automation session and cleanup\"\"\"\n        if session_id not in self.active_sessions:\n            logger.warning(f\"Session not found: {session_id}\")\n            return\n        \n        session = self.active_sessions[session_id]\n        \n        try:\n            logger.info(f\"Ending automation session: {session_id}\")\n            \n            # Stop emulator if it's an emulator session\n            if session.emulator_instance:\n                avd_name = session.session_state.get('avd_name')\n                if avd_name:\n                    self.emulator_manager.stop_emulator(avd_name)\n            \n            # Disconnect UIAutomator2\n            if session.device_id:\n                self.ui_manager.disconnect_device(session.device_id)\n            \n            # Remove from active sessions\n            del self.active_sessions[session_id]\n            \n            logger.info(f\"Session ended successfully: {session_id}\")\n            \n        except Exception as e:\n            logger.error(f\"Error ending session {session_id}: {e}\")\n    \n    def get_active_sessions(self) -> Dict[str, Dict]:\n        \"\"\"Get information about all active sessions\"\"\"\n        sessions_info = {}\n        \n        for session_id in self.active_sessions.keys():\n            info = self.get_session_info(session_id)\n            if info:\n                sessions_info[session_id] = info\n        \n        return sessions_info\n    \n    def end_all_sessions(self):\n        \"\"\"End all active sessions\"\"\"\n        session_ids = list(self.active_sessions.keys())\n        for session_id in session_ids:\n            self.end_automation_session(session_id)\n    \n    def __del__(self):\n        \"\"\"Cleanup when orchestrator is destroyed\"\"\"\n        try:\n            self.end_all_sessions()\n        except:\n            pass

# Global orchestrator\n_android_orchestrator = None\n\ndef get_android_orchestrator() -> AndroidAutomationOrchestrator:\n    \"\"\"Get global Android automation orchestrator\"\"\"\n    global _android_orchestrator\n    if _android_orchestrator is None:\n        _android_orchestrator = AndroidAutomationOrchestrator()\n    return _android_orchestrator\n\ndef cleanup_android_automation():\n    \"\"\"Cleanup function for graceful shutdown\"\"\"\n    global _android_orchestrator\n    if _android_orchestrator:\n        _android_orchestrator.end_all_sessions()\n\n# Register cleanup handler\nimport atexit\natexit.register(cleanup_android_automation)\n\nif __name__ == \"__main__\":\n    # Test orchestrator\n    orchestrator = AndroidAutomationOrchestrator()\n    \n    try:\n        print(\"Testing Android Automation Orchestrator...\")\n        \n        # Create emulator session\n        session_id = orchestrator.create_emulator_session('pixel_6_api_30', headless=True)\n        \n        if session_id:\n            print(f\"Created session: {session_id}\")\n            \n            # Get session info\n            info = orchestrator.get_session_info(session_id)\n            print(f\"Session info: {info}\")\n            \n            # Take screenshot\n            screenshot = orchestrator.take_session_screenshot(session_id)\n            print(f\"Screenshot: {screenshot}\")\n            \n            # Test human-like interactions\n            print(\"Testing human tap...\")\n            orchestrator.perform_human_tap(session_id, 540, 960)\n            \n            print(\"Testing human swipe...\")\n            orchestrator.perform_human_swipe(session_id, 100, 100, 900, 1800)\n            \n            # Wait a bit\n            time.sleep(5)\n            \n            # End session\n            orchestrator.end_automation_session(session_id)\n            print(\"Session ended\")\n        \n        print(\"Orchestrator test completed successfully\")\n        \n    except KeyboardInterrupt:\n        print(\"Interrupted by user\")\n    except Exception as e:\n        print(f\"Test error: {e}\")\n    finally:\n        orchestrator.end_all_sessions()